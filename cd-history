#!/usr/bin/python

# This software is distributed under the "Simplified BSD license":
#
# Copyright Michael Cook <michael@waxrat.com>. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#    1. Redistributions of source code must retain the above copyright notice,
#       this list of conditions and the following disclaimer.
#
#    2. Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

#
# In ~/.bashrc:
#   cd () { local cmd; cmd="$(cd-history "$@")" && eval "$cmd"; }
#   cdh () { cd-history --list | less -S +G "$@"; }
#

import sys, os, re
from stat import *

this = os.path.basename(sys.argv.pop(0)) # this script's name

max_history = 50
home = os.environ["HOME"]
history_file_name = os.path.join(home, "site", "cd_history")

class history_entry:
    def __init__(self, pathname, num):
        self.pathname = pathname
        self.num = num

history = list()

def append_to_history(pathname, num=None):
    """Append the given pathname to the history.
       If already in the history, move it to the end.
       Return true if any changes are made, false otherwise."""
    global history

    if num is None:
        num = 1
        for e in history:
            if e.pathname == pathname:
                num = e.num
                break
            if num <= e.num:
                num = e.num + 1

    if history and history[-1].pathname == pathname:
        return False;

    history = [e for e in history if e.pathname != pathname]
    history = history[1-max_history:]
    history.append(history_entry(pathname, num))
    return True

def shell_quote(s):
    if not re.search(r'[^@%\w:,./=+-]', s):
        return s
    return "'" + re.sub(r"'", r"'\''", s) + "'"

def load_history():
    try:
        with open(history_file_name) as f:
            lines = f.readlines()
    except IOError as e:
        if e.strerror != "No such file or directory":
            raise
        return

    for line in lines:
        line = line.rstrip("\n")
        num, pathname = line.split("\t")
        num = int(num)
        append_to_history(pathname, num)

def save_history():
    tmp = history_file_name + "." + str(os.getpid()) + "~"
    with open(tmp, "w") as f:
        for e in history:
            f.write(str(e.num) + "\t" + e.pathname + "\n")
    os.rename(tmp, history_file_name)

def recent(n):
    i = len(history) - n - 1
    if i < 0 or i >= len(history):
        sys.exit("No history entry " + str(n))
    return history[i].pathname

def best_match(pathname):
    if re.match(r'^-+$', pathname):
        # Some number of dashes (e.g, "-", "--", "---", ... means use one of
        # the last directories in the history.  If the very last directory is
        # the same as the current working directory, then ignore it.  Then use
        # the Nth from last directory in the history where N is the number of
        # dashes.
        return recent(len(pathname))

    if re.match(r'^-\d+$', pathname):
        # "-N" means use the Nth from the last directory in the history.
        return recent(-int(pathname))

    if re.match(r'^\d+$', pathname):
        # "N" means use directory number N in the history.
        num = int(pathname)
        for e in history:
            if num == e.num:
                return e.pathname
        sys.exit("No directory number %d in history" % num)

    # "%foo" means the directory that ends with "foo".
    # "%foo%" means the directory that contains "foo" anywhere.
    # There must be exactly one match or else it's an error.
    if pathname.startswith("%"):
        base = pathname[1:].lower()
        matches = list()
        if pathname.endswith("%"):
            base = base[0:-1]
            matcher = lambda d: base in d
        else:
            matcher = lambda d: d.endswith(base)
        for e in reversed(history):
            if matcher(e.pathname.lower()):
                matches.append((e.num, e.pathname))
        if not matches:
            sys.exit("No match: " + shell_quote(pathname))
        if len(matches) != 1:
            sys.exit("\n".join(["Multiple matches: " + shell_quote(pathname)] +
                               map(lambda v: "%4d %s" % v,
                                   reversed(matches))))
        return matches[0][1]

    # If pathname references an existing directory, use it.
    if os.path.isdir(pathname):
        return os.path.abspath(pathname)

    sys.exit("No such directory: " + shell_quote(pathname))

def append_cwd():
    # It's possible (if unlikely) that the current directory doesn't actually
    # exist in the file system any more.  So catch and ignore.
    try:
        cwd = os.path.abspath(".")
    except OSError as e:
        if e.strerror != "No such file or directory":
            raise
        print >>sys.stderr, "%s: Can't determine current directory" % this
        return False
    return append_to_history(cwd)

def change_dir(pathname):
    # Always store the current directory to the history before appending the
    # new directory.
    changed = False
    if append_cwd():
        changed = True
    if append_to_history(pathname):
        changed = True
    if changed:
        save_history()
    # Print the bash command to chdir to the selected directory.
    e = history[-1]
    print >>sys.stderr, e.num, e.pathname
    print "builtin", "cd", shell_quote(pathname)

def show_history():
    load_history()
    if append_cwd():
        save_history()
    for e in history:
        print "%4d %s" % (e.num, e.pathname)

# ----------------------------------------------------------------------------

if len(sys.argv) == 1 and sys.argv[0] == "--list":
    show_history()
elif len(sys.argv) == 1:
    load_history()
    pathname = best_match(sys.argv.pop(0))
    change_dir(pathname)
elif len(sys.argv) == 0:
    load_history()
    change_dir(home)
else:
    sys.exit("wrong number of arguments: " +
             " ".join(map(shell_quote, sys.argv)))
